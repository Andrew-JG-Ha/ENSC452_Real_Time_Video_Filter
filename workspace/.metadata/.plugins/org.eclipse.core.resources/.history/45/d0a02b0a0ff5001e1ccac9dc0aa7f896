#include "filters.h"

FILTER filterConstructor(int* filterArray) {
	FILTER filter;
	filter.topLeft = filterArray[0];
	filter.top = filterArray[1];
	filter.topRight = filterArray[2];
	filter.left = filterArray[3];
	filter.centre = filterArray[4];
	filter.right = filterArray[5];
	filter.botLeft = filterArray[6];
	filter.bot = filterArray[7];
	filter.botRight = filterArray[8];
}

void initFilters() {
	int sobel = {1, 0, -1, 2, 0, -2, 1, 0 ,-1};
	sobelKernel = filterConstructor(sobel);

	int gaussian = {1, 2, 1, 2, 4, 2, 1, 2, 1};
	gaussianKernel = filterConstructor(gaussian);

	int sharpen = {0, -1, 0, -1, 5, -1, 0, -1, 0};
	sharpenKernel = filterConstructor(sharpen);

	int ridge = {-1, -1, -1, -1, 8, -1, -1, -1, -1};
	ridgeKernel = filterConstructor(ridge);

	int user = {1, 1, 1, 1, 1, 1, 1, 1, 1};
}

void applyKernelGrey(int* source, int* destination, FILTER filter) {
	int centreAddress, topLeftAddress, topAddress, topRightAddress, rightAddress, botRightAddress, botAddress, botLeftAddress, leftAddress;
	int centreVal, topLeftVal, topVal, topRightVal, rightVal, botRightVal, botVal, botLeftVal, leftVal, result;
	for (int row = 0; row < 480; row++) {
		for (int column = 0; column < 640; column++) {
			centreAddress = row * 640 + column;
			topLeftAddress = (row - 1) * 640 + (column - 1);
			topAddress = (row - 1) * 640 + column;
			topRightAddress = (row - 1) * 640 + (column + 1);
			rightAddress = row * 640 + (column + 1);
			botRightAddress = (row + 1) * 640 + (column + 1);
			botAddress = (row + 1) * 640 + column;
			botLeftAddress = (row + 1) * 640 + (column - 1);
			leftAddress = row * 640 + (column - 1);

			topLeftVal = 0;
			topVal = 0;
			topRightVal = 0;
			rightVal = 0;
			botRightVal = 0;
			botVal = 0;
			botLeftVal = 0;
			leftVal = 0;

			if (row % 479 == 0) {
				if (column % 639 == 0) {
					// at corners of image
					if (row == 0 && column == 0) {
						// top left corner
						rightVal = source[rightAddress];
						botRightVal = source[botRightAddress];
						botVal = source[botAddress];
					}
					else if (row == 0 && column == 639) {
						// top right corner
						leftVal = source[leftAddress];
						botLeftVal = source[botLeftAddress];
						botVal = source[botAddress];
					}
					else if (row == 479 && column == 639) {
						// bot right corner
						leftVal = source[leftAddress];
						topLeftVal = source[topLeftAddress];
						topVal = source[topAddress];
					}
					else {
						// bot left corner
						rightVal = source[rightAddress];
						topRightVal = source[topRightAddress];
						topVal = source[topAddress];
					}
				}
				else {
					// at horizontal edge of image
					if (row == 0) {
						// at top edge
						leftVal = source[leftAddress];
						botLeftVal = source[botLeftAddress];
						botVal = source[botAddress];
						botRightVal = source[botRightAddress];
						rightVal = source[rightAddress];
					}
					else {
						// at bottom edge
						leftVal = source[leftAddress];
						topLeftVal = source[topLeftAddress];
						topVal = source[topAddress];
						topRightVal = source[topRightAddress];
						rightVal = source[rightAddress];
					}
				}

			}
			else {
				if (column % 639 == 0) {
					// at vertical edge of image
					if (column == 0) {
						// at left most edge
						topVal = source[topAddress];
						topRightVal = source[topRightAddress];
						rightVal = source[rightAddress];
						botRightVal = source[botRightAddress];
						botVal = source[botAddress];
					}
					else {
						// at right most edge
						topVal = source[topAddress];
						topLeftVal = source[topLeftAddress];
						leftVal = source[leftAddress];
						botLeftVal = source[botLeftAddress];
						botVal = source[botAddress];
					}
				}
				else {
					// not at edge or corner of image
					topLeftVal = source[topLeftAddress];
					topVal = source[topAddress];
					topRightVal = source[topRightAddress];
					rightVal = source[rightAddress];
					botRightVal = source[botRightAddress];
					botVal = source[botAddress];
					botLeftVal = source[botLeftAddress];
					leftVal = source[leftAddress];
				}
			}

			centreVal = source[centreAddress] & 0x000000F0;
			topLeftVal = topLeftVal & 0x000000F0;
			topVal = topVal & 0x000000F0;
			topRightVal = topRightVal & 0x000000F0;
			rightVal = rightVal & 0x000000F0;
			botRightVal = botRightVal & 0x000000F0;
			botVal = botVal & 0x000000F0;
			botLeftVal = botLeftVal & 0x000000F0;
			leftVal = leftVal & 0x000000F0;

			result =  (filter.topLeft * topLeftVal) + (filter.top * topVal) + (filter.topRight * topRightVal)
					+ (filter.left * leftVal) + (filter.centre * centreVal) + (filter.right * rightVal)
					+ (filter.botLeft * botLeftVal) + (filter.bot * botVal) + (filter.botRight * botRightVal);

			if (result > 0x000000F0 || -result > 0x000000F0) {
				result = 0x000000F0;
			}
			else {
				if (result < 0x00000000) {
					result = -result;
					result = result & 0x000000F0;
				}
				else {
					result = result & 0x000000F0;
				}
			}
			destination[centreAddress] = result | result << 8 | result << 16;
		}
	}
}


void applyKernelRGB(int* source, int* destination, FILTER filter, int scalingFactor) {
	int centreAddress, topLeftAddress, topAddress, topRightAddress, rightAddress, botRightAddress, botAddress, botLeftAddress, leftAddress;
	int topLeftVal, topVal, topRightVal, rightVal, botRightVal, botVal, botLeftVal, leftVal;
	int centreValR, topLeftValR, topValR, topRightValR, rightValR, botRightValR, botValR, botLeftValR, leftValR, resultR;
	int centreValG, topLeftValG, topValG, topRightValG, rightValG, botRightValG, botValG, botLeftValG, leftValG, resultG;
	int centreValB, topLeftValB, topValB, topRightValB, rightValB, botRightValB, botValB, botLeftValB, leftValB, resultB;
	for (int row = 0; row < 480; row++) {
		for (int column = 0; column < 640; column++) {
			centreAddress = row * 640 + column;
			topLeftAddress = (row - 1) * 640 + (column - 1);
			topAddress = (row - 1) * 640 + column;
			topRightAddress = (row - 1) * 640 + (column + 1);
			rightAddress = row * 640 + (column + 1);
			botRightAddress = (row + 1) * 640 + (column + 1);
			botAddress = (row + 1) * 640 + column;
			botLeftAddress = (row + 1) * 640 + (column - 1);
			leftAddress = row * 640 + (column - 1);

			topLeftVal = 0;
			topVal = 0;
			topRightVal = 0;
			rightVal = 0;
			botRightVal = 0;
			botVal = 0;
			botLeftVal = 0;
			leftVal = 0;

			if (row % 479 == 0) {
				if (column % 639 == 0) {
					// at corners of image
					if (row == 0 && column == 0) {
						// top left corner
						rightVal = destination[rightAddress];
						botRightVal = destination[botRightAddress];
						botVal = destination[botAddress];
					}
					else if (row == 0 && column == 639) {
						// top right corner
						leftVal = destination[leftAddress];
						botLeftVal = destination[botLeftAddress];
						botVal = destination[botAddress];
					}
					else if (row == 479 && column == 639) {
						// bot right corner
						leftVal = destination[leftAddress];
						topLeftVal = destination[topLeftAddress];
						topVal = destination[topAddress];
					}
					else {
						// bot left corner
						rightVal = destination[rightAddress];
						topRightVal = destination[topRightAddress];
						topVal = destination[topAddress];
					}
				}
				else {
					// at horizontal edge of image
					if (row == 0) {
						// at top edge
						leftVal = destination[leftAddress];
						botLeftVal = destination[botLeftAddress];
						botVal = destination[botAddress];
						botRightVal = destination[botRightAddress];
						rightVal = destination[rightAddress];
					}
					else {
						// at bottom edge
						leftVal = destination[leftAddress];
						topLeftVal = destination[topLeftAddress];
						topVal = destination[topAddress];
						topRightVal = destination[topRightAddress];
						rightVal = destination[rightAddress];
					}
				}

			}
			else {
				if (column % 639 == 0) {
					// at vertical edge of image
					if (column == 0) {
						// at left most edge
						topVal = destination[topAddress];
						topRightVal = destination[topRightAddress];
						rightVal = destination[rightAddress];
						botRightVal = destination[botRightAddress];
						botVal = destination[botAddress];
					}
					else {
						// at right most edge
						topVal = destination[topAddress];
						topLeftVal = destination[topLeftAddress];
						leftVal = destination[leftAddress];
						botLeftVal = destination[botLeftAddress];
						botVal = destination[botAddress];
					}
				}
				else {
					// not at edge or corner of image
					topLeftVal = destination[topLeftAddress];
					topVal = destination[topAddress];
					topRightVal = destination[topRightAddress];
					rightVal = destination[rightAddress];
					botRightVal = destination[botRightAddress];
					botVal = destination[botAddress];
					botLeftVal = destination[botLeftAddress];
					leftVal = destination[leftAddress];
				}
			}

			centreValR = destination[centreAddress] & 0x000000F0;
			topLeftValR = topLeftVal & 0x000000F0;
			topValR = topVal & 0x000000F0;
			topRightValR = topRightVal & 0x000000F0;
			rightValR = rightVal & 0x000000F0;
			botRightValR = botRightVal & 0x000000F0;
			botValR = botVal & 0x000000F0;
			botLeftValR = botLeftVal & 0x000000F0;
			leftValR = leftVal & 0x000000F0;

			resultR = (filter.topLeft * topLeftValR) + (filter.top * topValR) + (filter.topRight * topRightValR)
					+ (filter.left * leftValR) + (filter.centre * centreValR) + (filter.right * rightValR)
					+ (filter.botLeft * botLeftValR) + (filter.bot * botValR) + (filter.botRight * botRightValR);
			resultR = (resultR >> scalingFactor) & 0x000000F0;

			centreValG = (destination[centreAddress] & 0x0000F000) >> 8;
			topLeftValG = (topLeftVal & 0x0000F000) >> 8;
			topValG = (topVal & 0x0000F000) >> 8;
			topRightValG = (topRightVal & 0x0000F000) >> 8;
			rightValG = (rightVal & 0x0000F000) >> 8;
			botRightValG = (botRightVal & 0x0000F000) >> 8;
			botValG = (botVal & 0x0000F000) >> 8;
			botLeftValG = (botLeftVal & 0x0000F000) >> 8;
			leftValG = (leftVal & 0x0000F000) >> 8;

			resultG = (filter.topLeft * topLeftValG) + (filter.top * topValG) + (filter.topRight * topRightValG)
					+ (filter.left * leftValG) + (filter.centre * centreValG) + (filter.right * rightValG)
					+ (filter.botLeft * botLeftValG) + (filter.bot * botValG) + (filter.botRight * botRightValG);
			resultG = (resultG >> scalingFactor) & 0x000000F0;

			centreValB = (destination[centreAddress] & 0x00F00000) >> 16;
			topLeftValB = (topLeftVal & 0x00F00000) >> 16;
			topValB = (topVal & 0x00F00000) >> 16;
			topRightValB = (topRightVal & 0x00F00000) >> 16;
			rightValB = (rightVal & 0x00F00000) >> 16;
			botRightValB = (botRightVal & 0x00F00000) >> 16;
			botValB = (botVal & 0x00F00000) >> 16;
			botLeftValB = (botLeftVal & 0x00F00000) >> 16;
			leftValB = (leftVal & 0x00F00000) >> 16;

			resultB = (filter.topLeft * topLeftValB) + (filter.top * topValB) + (filter.topRight * topRightValB)
					+ (filter.left * leftValB) + (filter.centre * centreValB) + (filter.right * rightValB)
					+ (filter.botLeft * botLeftValB) + (filter.bot * botValB) + (filter.botRight * botRightValB);
			resultB = (resultB >> scalingFactor) & 0x000000F0;

			source[centreAddress] = resultR | resultG << 8 | resultB << 16;
		}
	}
}



